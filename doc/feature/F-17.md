# F-17: 错误处理和消息一致性测试

## 特性描述

F-17 特性专门测试 Excel-DB MCP 工具的错误处理机制，确保在各种异常情况下能够提供一致、清晰、用户友好的错误信息。该测试覆盖文件访问错误、SQL 语法错误、数据格式错误等多种场景，验证错误处理的完整性和可靠性。

## 功能规范

### 1. 错误类型覆盖
- **文件访问错误**: 文件不存在、权限不足、文件损坏
- **数据结构错误**: 工作表不存在、列名不存在、数据格式错误
- **SQL 语法错误**: 无效 SQL 语句、语法错误、参数错误
- **系统错误**: 内存不足、并发冲突、网络错误

### 2. 错误消息质量
- **信息完整性**: 包含错误类型、具体原因、建议解决方案
- **用户友好性**: 使用清晰易懂的语言，避免技术术语
- **一致性**: 相同类型错误使用统一的消息格式
- **国际化支持**: 支持多语言错误消息

### 3. 错误恢复机制
- **状态一致性**: 错误后系统状态保持一致
- **资源清理**: 自动清理错误操作占用的资源
- **重试机制**: 支持可恢复错误的自动重试
- **并发安全**: 多个操作同时出错时的安全处理

## 支持的测试场景

### 文件访问错误测试
```javascript
// 文件不存在
try {
  await excelQuery.getWorksheetInfo('/path/to/nonexistent.xlsx');
} catch (error) {
  // 验证错误消息包含文件路径和"not found"信息
}

// 权限不足
try {
  await excelQuery.getWorksheetInfo('/restricted/file.xlsx');
} catch (error) {
  // 验证错误消息包含权限相关信息
}
```

### 数据结构错误测试
```javascript
// 工作表不存在
try {
  await excelQuery.executeQuery('SELECT * FROM NonExistentSheet', 'file.xlsx');
} catch (error) {
  // 验证错误消息包含工作表名称和存在性提示
}

// 列名不存在
try {
  await excelQuery.executeQuery('SELECT NonExistentColumn FROM Sheet1', 'file.xlsx');
} catch (error) {
  // 验证错误消息包含列名和可用列提示
}
```

### SQL 语法错误测试
```javascript
// 无效 SQL 语法
try {
  await excelQuery.executeQuery('INVALID SQL SYNTAX', 'file.xlsx');
} catch (error) {
  // 验证错误消息包含语法错误位置和修正建议
}

// 空查询
try {
  await excelQuery.executeQuery('', 'file.xlsx');
} catch (error) {
  // 验证错误消息提示查询不能为空
}
```

### 并发错误处理测试
```javascript
// 并发操作错误处理
const promises = [
  excelQuery.executeQuery('SELECT * FROM Sheet1', 'file1.xlsx'),
  excelQuery.executeQuery('SELECT * FROM NonExistent', 'file2.xlsx'),
  excelQuery.executeQuery('INVALID SQL', 'file3.xlsx')
];

const results = await Promise.allSettled(promises);
// 验证每个操作的错误都被正确处理
```

## 使用示例

### 示例 1: 基本错误处理
```javascript
const { ExcelSqlQuery } = require('excel-sql-query');
const excelQuery = new ExcelSqlQuery();

try {
  const result = await excelQuery.executeQuery('SELECT * FROM Sheet1', 'data.xlsx');
  console.log('查询成功:', result);
} catch (error) {
  console.error('查询失败:', error.message);
  
  // 根据错误类型进行不同处理
  if (error.message.includes('not found')) {
    console.log('建议: 检查文件路径是否正确');
  } else if (error.message.includes('Worksheet')) {
    console.log('建议: 检查工作表名称是否存在');
  } else if (error.message.includes('syntax')) {
    console.log('建议: 检查 SQL 语法是否正确');
  }
}
```

### 示例 2: 错误恢复处理
```javascript
async function robustQuery(query, filePath, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await excelQuery.executeQuery(query, filePath);
    } catch (error) {
      console.log(`尝试 ${attempt} 失败:`, error.message);
      
      if (attempt === maxRetries) {
        throw new Error(`查询失败，已重试 ${maxRetries} 次: ${error.message}`);
      }
      
      // 等待后重试
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
}
```

### 示例 3: 错误分类处理
```javascript
function categorizeError(error) {
  const message = error.message.toLowerCase();
  
  if (message.includes('not found') || message.includes('enoent')) {
    return { type: 'FILE_NOT_FOUND', severity: 'HIGH', recoverable: false };
  } else if (message.includes('permission') || message.includes('eacces')) {
    return { type: 'PERMISSION_DENIED', severity: 'HIGH', recoverable: false };
  } else if (message.includes('worksheet') || message.includes('table')) {
    return { type: 'WORKSHEET_NOT_FOUND', severity: 'MEDIUM', recoverable: true };
  } else if (message.includes('column') || message.includes('field')) {
    return { type: 'COLUMN_NOT_FOUND', severity: 'MEDIUM', recoverable: true };
  } else if (message.includes('syntax') || message.includes('parse')) {
    return { type: 'SQL_SYNTAX_ERROR', severity: 'LOW', recoverable: true };
  } else {
    return { type: 'UNKNOWN_ERROR', severity: 'HIGH', recoverable: false };
  }
}
```

## 实现细节

### 测试用例覆盖
1. **文件不存在错误**: 验证文件路径错误的处理
2. **工作表不存在错误**: 验证工作表名称错误的处理
3. **列名不存在错误**: 验证列名错误的处理
4. **SQL 语法错误**: 验证各种 SQL 语法错误
5. **损坏文件错误**: 验证文件格式错误的处理
6. **空文件错误**: 验证空文件的处理
7. **权限错误**: 验证文件权限问题的处理
8. **错误消息友好性**: 验证错误消息的用户友好程度
9. **错误恢复**: 验证错误后的状态恢复
10. **并发错误处理**: 验证并发操作的错误处理

### 错误消息标准
- **格式**: `[错误类型] 具体错误描述 - 建议解决方案`
- **内容**: 包含足够信息帮助用户定位和解决问题
- **语言**: 使用简洁明了的自然语言
- **一致性**: 相同类型错误使用相同的消息模板

### 性能要求
- 错误处理不应显著影响正常操作性能
- 错误恢复时间 < 100ms
- 内存泄漏检测和防护
- 并发错误处理的线程安全

## 注意事项

### 1. 错误信息安全
- 不暴露系统内部路径和敏感信息
- 避免在错误消息中包含用户数据
- 防止错误消息被用于系统探测

### 2. 错误恢复策略
- 区分可恢复和不可恢复错误
- 实现适当的重试机制
- 确保错误后资源正确释放

### 3. 用户体验
- 提供具体的解决建议
- 避免技术术语，使用用户友好的语言
- 支持错误代码查询和帮助文档

### 4. 调试支持
- 在开发模式下提供详细的调试信息
- 支持错误日志记录和分析
- 提供错误重现的最小示例

## 对应测试用例

测试用例位置: `test/test-case/tc-f-17.js`

运行测试:
```bash
node test/test.js
```

该测试用例包含 10 个主要测试场景，覆盖各种错误处理情况，确保系统在异常情况下的稳定性和用户体验。